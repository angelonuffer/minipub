// server.js
const WebSocket = require('ws');
const { getInitialState, handleMessage } = require('./minipub');
const { v4: uuidv4 } = require('uuid'); // For generating unique client IDs

const server = new WebSocket.Server({ port: 8080 });
let state = getInitialState();

// Keep track of WebSocket connections by client ID
const clients = new Map();

server.on('connection', ws => {
  const clientId = uuidv4();
  clients.set(clientId, ws);
  console.log(`Client ${clientId} connected`);

  // Add client to the global list in the state
  // This ensures the client is known for handleMessage logic,
  // even if they don't immediately subscribe to a topic.
  if (!state.clients.includes(clientId)) {
    state.clients.push(clientId);
  }

  ws.on('message', message => {
    console.log(`Received message from ${clientId}`);
    // Ensure message is a Buffer
    const messageBuffer = Buffer.isBuffer(message) ? message : Buffer.from(message);

    const newState = handleMessage(state, clientId, messageBuffer);
    state = newState;

    state.messagesToSend.forEach(msg => {
      const destinationClient = clients.get(msg.destination);
      if (destinationClient && destinationClient.readyState === WebSocket.OPEN) {
        destinationClient.send(msg.message);
        console.log(`Sent message to ${msg.destination}`);
      }
    });
    // Clear messagesToSend after processing
    state.messagesToSend = [];
  });

  ws.on('close', () => {
    console.log(`Client ${clientId} disconnected`);
    clients.delete(clientId);

    // Simulate an unsubscribe from all topics for the disconnected client
    // This requires creating a "farewell" message of type 2 for each topic
    // the client was subscribed to.
    // The payload for this farewell message can be empty or a generic message.
    const farewellPayload = Buffer.from(`Client ${clientId} has disconnected`);

    Object.keys(state.topics).forEach(topic => {
      if (state.topics[topic].includes(clientId)) {
        // Construct a generic unsubscribe message for each topic
        // Topic string needs to be 128 bytes
        const topicBuffer = Buffer.alloc(128);
        topicBuffer.write(topic, 'utf-8');

        const unsubscribeMessage = Buffer.concat([Buffer.from([2]), topicBuffer, farewellPayload]);
        const newState = handleMessage(state, clientId, unsubscribeMessage);
        state = newState; // Update state after each simulated unsubscribe

        // Process any messages generated by the unsubscribe (e.g., farewells to others)
        state.messagesToSend.forEach(msg => {
          const destinationClient = clients.get(msg.destination);
          if (destinationClient && destinationClient.readyState === WebSocket.OPEN) {
            destinationClient.send(msg.message);
          }
        });
        state.messagesToSend = []; // Clear after sending
      }
    });
     // Finally, remove the client from the global list of clients in the state
    const clientIndex = state.clients.indexOf(clientId);
    if (clientIndex > -1) {
        state.clients.splice(clientIndex, 1);
    }
  });

  ws.on('error', error => {
    console.error(`Error with client ${clientId}:`, error);
    // Consider handling client disconnection here as well if not already handled by 'close'
  });
});

console.log('WebSocket server started on port 8080');
